//P2495 [SDOI2011]消耗战
//每次树上有k个点，求切断1到达所有K点的最小花费

int N, Q;
int a[MAX];

//------------------树边----------------
struct edge {
    int nxt, to, w;
    edge() {}
    edge(int nxt, int to, int w) : nxt(nxt), to(to), w(w) {}
} e[MAX << 1];

int head[MAX], cnt;

void add(int u, int v, int w) {
    e[++cnt] = edge(head[u], v, w); head[u] = cnt;
}
//---------------虚树边-------------------
vector<int> g[MAX];

void add_edge(int x, int y) {
    g[x].push_back(y);
}
//-----------预处理--------------------
int d[MAX], siz[MAX], dfn[MAX], topfa[MAX], son[MAX], dep[MAX], fa[MAX], tot;
ll cost[MAX];

void dfs1(int u, int f) {
    siz[u] = 1, fa[u] = f;
    for (int i = head[u], v = e[i].to; i; i = e[i].nxt, v = e[i].to)
        if (v != f) {
            dep[v] = dep[u] + 1;
            cost[v] = min(cost[u], (ll)e[i].w);//直接割掉当前边的花费
            dfs1(v, u);
            siz[u] += siz[v];
            if (siz[v] > siz[son[u]])
                son[u] = v;
        }
}

void dfs2(int u, int topf) {
    topfa[u] = topf, dfn[u] = ++tot;
    if (!son[u]) return;
    dfs2(son[u], topf);
    for (int i = head[u], v = e[i].to; i; i = e[i].nxt, v = e[i].to)
        if (!topfa[v]) dfs2(v, v);
}

int LCA(int x, int y) {
    while (topfa[x] != topfa[y]) {
        if (dep[topfa[x]] < dep[topfa[y]]) swap(x, y);
        x = fa[topfa[x]];
    }
    if (dep[x] > dep[y]) swap(x, y);
    return x;
}
//-----------建立虚树------------
int st[MAX], top;

void insert(int x) {
    if (top == 1) {
        st[++top] = x;
        return;
    }
    int lca = LCA(x, st[top]);
    if (lca == st[top]) return;
    while (top > 1 && dfn[st[top - 1]] >= dfn[lca])
        add_edge(st[top - 1], st[top]), top--;
    if (lca != st[top]) add_edge(lca, st[top]), st[top] = lca;
    st[++top] = x;
}

ll dp(int x) {
    if (g[x].empty()) return cost[x];
    ll sum = 0;//子树中单独割掉之和
    for (auto & i : g[x])
        sum += dp(i);
    g[x].clear();//每次遍历都会清空
    return min(sum, cost[x]);//花费为直接割掉当前边和子树和最小的那个
}

bool cmp(const int &x, const int &y) {//按时间戳排序
    return dfn[x] < dfn[y];
}

void init() {
    cnt = tot = 0;
    memset(head, 0, sz(head));
}

int main() {
    init();
    scanf("%d", &N);
    for (int i = 1; i < N; i++) {
        int u, v, w; scanf("%d%d%d", &u, &v, &w);
        add(u, v, w); add(v, u, w);
    }
    cost[1] = 9e18;
    dep[1] = 1;//rt
    dfs1(1, 0);
    dfs2(1, 1);

    scanf("%d", &Q);
    while (Q--) {
        int K; scanf("%d", &K);
        for (int i = 1; i <= K; i++) scanf("%d", &a[i]);
        sort(a + 1, a + 1 + K, cmp);
        st[top = 1] = 1;
        for (int i = 1; i <= K; i++) insert(a[i]);
        while (top > 0) add_edge(st[top - 1], st[top]), top--;
        printf("%lld\n", dp(1));
    }

    return 0;
}


//P3320 [SDOI2015]寻宝游戏
//树的图上遍历所有的宝藏点并回到终点，每次Q增加一个宝藏点
//不难证明，这一题从任意一个有宝藏的起点出发的答案都是等价的
// （因为要回到起点，所以路径相当于是一个环），那么答案是什么呢，
// 其实就是dis(a[1],a[2])+dis(a[2],a[3])+・・・+dis(a[k-1],a[k])+dis(a[k],a[1])，
// k为当前有宝藏的村庄数，a数组存放着按dfs序排序过后的有宝藏的村庄，
// 那么每一次加一个点只要在原基础上删掉它按dfs序的前一个点和后一个点的距离、加上自己与那两个点的距离就好了（注意边界情况，即dfs序是最小的或者是最大的），删除同理。

//有宝藏的村庄用一个set维护就好了，一次操作复杂度O（logn），树上点之间的距离可以用树链剖分或者是倍增实现（这里用的是倍增）


int N, M;

//------------------树边----------------
struct edge {
    int nxt, to, w;
    edge() {}
    edge(int nxt, int to, int w) : nxt(nxt), to(to), w(w) {}
} e[MAX << 1];

int head[MAX], cnt;

void add(int u, int v, int w) {
    e[++cnt] = edge(head[u], v, w); head[u] = cnt;
}
//-----------预处理--------------------

int fz[MAX][20];
int dep[MAX], dfn[MAX], id[MAX], tot;
ll dis[MAX];

void dfs(int u, int fa) {
    dfn[u] = ++tot, id[tot] = u, dep[u] = dep[fz[u][0] = fa] + 1;
    for (int i = 1; (1 << i) <= dep[u]; i++)
        fz[u][i] = fz[fz[u][i - 1]][i - 1];
    for (int i = head[u], v = e[i].to; i; i = e[i].nxt, v = e[i].to)
        if (v != fa) {
            dis[v] = dis[u] + e[i].w;
            dfs(v, u);
        }
}

int lca(int x, int y) {
    if (dep[x] < dep[y])
        swap(x, y);
    for (int d = dep[x] - dep[y], j = 0; d; d >>= 1, ++j)
        if (d & 1) x = fz[x][j];
    if (x == y) return x;
    for (int j = 16; ~j; --j) if (fz[x][j] != fz[y][j])
            x = fz[x][j], y = fz[y][j];
    return fz[x][0];
}

inline ll get_dis(int x, int y) {
    return dis[x] + dis[y] - 2 * dis[lca(x, y)];
}

//--------------------set--------------------

set<int> st;
set<int>::iterator it;
int vis[MAX];

int main() {
    scanf("%d%d", &N, &M);
    for (int i = 1; i < N; i++) {
        int u, v, w; scanf("%d%d%d", &u, &v, &w);
        add(u, v, w); add(v, u, w);
    }
    dfs(1, 0);
    ll ans = 0;
    while (M--) {
        int x; scanf("%d", &x);
        int v = dfn[x];
        if (!vis[x]) st.insert(v);
        int pre = id[(it = st.lower_bound(v)) == st.begin() ? *--st.end() : *--it];
        int pst = id[(it = st.upper_bound(v)) == st.end() ? *st.begin() : *it];
        if (vis[x]) st.erase(v);
        ll num = get_dis(pre, x) + get_dis(pst, x) - get_dis(pre, pst);
        if (vis[x]) ans -= num;
        else ans += num;
        vis[x] ^= 1;
        printf("%lld\n", ans);
    }

    return 0;
}